## Synthesized Integration Plan: Plan Review for meet-ai

After reviewing all three deep-dives (hook-legend on hooks, ui-legend on frontend, and my architecture analysis), here's the converged implementation plan.

---

### Consensus Points (All 3 Agree)

1. **Use `PermissionRequest` on `ExitPlanMode`** (not PreToolUse) — this is what plannotator uses and it's the correct hook type for controlling plan decisions
2. **No local server** — unlike plannotator, we already have the chat UI open. Plans render as cards in the message stream
3. **Follow the ask-user pattern** — send to API → poll for decision → output JSON to stdout
4. **Block-level annotations for MVP** — skip text-selection complexity (web-highlighter), use block-level click-to-annotate instead
5. **Reuse plannotator's `exportDiff()` format** — agents already know how to parse this feedback format

---

### Architecture Decision: Message-Based vs Separate Table

**Decision: Hybrid approach.** Use the existing messages table for the plan content (so it appears in the chat stream naturally) + a new `plan_decisions` table for the decision state (so the hook can poll efficiently).

**Why not just messages?**

- The hook needs to poll for a specific decision status, not scan all messages
- Decision state (pending/approved/denied + feedback) doesn't fit cleanly in a chat message
- We need atomicity — the decision should be a single state transition, not a race between multiple messages

**Why not just a new table?**

- The plan content should appear in the chat stream so all team members see it
- It should be part of the message history when scrolling back

**Schema:**

```sql
CREATE TABLE plan_decisions (
  id TEXT PRIMARY KEY,
  message_id TEXT NOT NULL,  -- references the plan message
  room_id TEXT NOT NULL,
  key_id TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'pending', -- pending|approved|denied
  feedback TEXT,             -- structured feedback on deny
  decided_by TEXT,           -- who made the decision
  decided_at TEXT,           -- ISO timestamp
  created_at TEXT NOT NULL DEFAULT (datetime('now'))
);
```

---

### Component Breakdown

#### 1. Hook: `packages/hooks/src/plan-review/index.ts`

```
stdin (PermissionRequest event)
  → parse event.tool_input.plan + event.permission_mode
  → find room via findRoomId(sessionId)
  → POST /api/rooms/:id/plan-reviews  (body: { plan_content, permission_mode })
  → returns { review_id, message_id }
  → poll GET /api/rooms/:id/plan-reviews/:review_id every 2s
  → on approved: stdout { hookSpecificOutput: { hookEventName: 'PermissionRequest', decision: { behavior: 'allow' } } }
  → on denied: stdout { hookSpecificOutput: { hookEventName: 'PermissionRequest', decision: { behavior: 'deny', message: feedback } } }
```

Timeout: 300s (5 min) — generous but not 4 days like plannotator, since our UI is always open

#### 2. API Endpoints

```
POST /api/rooms/:id/plan-reviews
  → creates message (sender: 'hook', content: plan_markdown, color: '#8b5cf6')
  → creates plan_decision record (status: 'pending')
  → broadcasts via DO WebSocket
  → returns { id: decision_id, message_id }

GET /api/rooms/:id/plan-reviews/:id
  → returns { status, feedback, decided_by, decided_at }
  → used by hook for polling

POST /api/rooms/:id/plan-reviews/:id/decide
  → body: { approved: boolean, feedback?: string, decided_by: string }
  → updates plan_decision status
  → broadcasts decision via DO WebSocket
  → returns { ok: true }
```

#### 3. UI Component: `PlanReviewCard`

Detected in MessageList by: `sender === 'hook' && color === '#8b5cf6'` (purple, distinct from question amber)

**States:**

- **Pending**: Shows plan markdown + Approve/Request Changes buttons
- **Approved**: Green accent, checkmark, collapse plan to summary
- **Denied**: Red accent, shows submitted feedback, collapse plan

**Rendering:**

- Simple markdown renderer (headings, code blocks, lists, paragraphs)
- Collapsible: long plans show first ~10 lines with 'Show more'
- No annotations in MVP — just approve/deny with optional feedback textarea

**Phase 2 Enhancements:**

- Block-level click-to-annotate (ui-legend's proposal)
- Annotation sidebar below the plan
- exportDiff() structured feedback format
- Syntax highlighting for code blocks

#### 4. Hook Config

`.claude/settings.json`:

```json
{
  "hooks": {
    "PermissionRequest": [
      {
        "matcher": "ExitPlanMode",
        "hooks": [
          {
            "type": "command",
            "command": ".claude/hooks/plan-review",
            "timeout": 300
          }
        ]
      }
    ]
  }
}
```

Shell wrapper `.claude/hooks/plan-review`:

```bash
#\!/usr/bin/env bash
exec bun run packages/hooks/src/plan-review/index.ts
```

---

### Implementation Order

1. **D1 migration**: Add `plan_decisions` table
2. **API routes**: Create/get/decide endpoints in `packages/worker/src/routes/plan-reviews.ts`
3. **Schemas**: Zod schemas for request/response validation
4. **PlanReviewCard**: React component with markdown rendering + approve/deny
5. **MessageList integration**: Detect plan review messages and render PlanReviewCard
6. **Hook script**: `packages/hooks/src/plan-review/index.ts` with read/post/poll/output
7. **Hook config**: Shell wrapper + settings.json entry
8. **WebSocket broadcast**: Broadcast decision events through DO
9. **Build + deploy**: `bun run deploy` from packages/worker
10. **Test**: Manual E2E with Claude Code in plan mode

---

### Open Questions for the Human

1. **Timeout duration**: 300s (5 min) or longer? The plan appears in the always-open chat UI, so the user should see it quickly. But if they step away...
2. **Multiple plans**: If Claude generates multiple plans in sequence, should each get its own card? Or should we only allow one pending review per room?
3. **Phase 2 priority**: Inline annotations or code review first? Plannotator supports both.
